# ä¸€ã€å˜é‡ä¸ä¸å¯å˜æ€§

## å˜é‡

- ä½¿ç”¨ let å£°æ˜å˜é‡

    `let x`

- Rust æ”¯æŒç±»å‹æ¨å¯¼ï¼Œä½†ä½ ä¹Ÿå¯ä»¥æ˜¾å¼åœ°æŒ‡å®šå˜é‡ç±»å‹

    `let x:i32 = 5 # æ˜¾å¼åœ°æŒ‡å®šä¸º i32 ç±»å‹`

- å˜é‡åä½¿ç”¨è›‡å½¢å‘½åæ³• (snake_case)ï¼Œè€Œæšä¸¾å’Œç»“æ„ä½“ä½¿ç”¨å¸•æ–¯å¡å‘½åæ³•(PascalCase)

    `let user_name`

    `struct UserName`

- å¦‚æœå˜é‡æ²¡æœ‰ä½¿ç”¨ï¼Œå¯ä»¥ä¸ºå…¶æ·»åŠ å‰ç½®ä¸‹åˆ’çº¿ï¼Œæ¶ˆé™¤è­¦å‘Š 

    `let _x`

- å¼ºåˆ¶ç±»å‹è½¬æ¢ 

    `let a = 3.1;  let b = a as i32`

- æ‰“å°å˜é‡   ï¼ˆ`{}`ä¸`{:?}` éœ€è¦å®ç°ç‰¹è´¨ï¼Œåœ¨ä¹‹åçš„ç« èŠ‚ä»‹ç»ï¼ŒåŸºç¡€ç±»å‹é»˜è®¤å®ç°ï¼‰

    `println!("val: {}, x")`

    `println!("val: {x}")`

## ä¸å¯å˜

ä¸å¯å˜æ€§æ—¶ Rust å®ç°å…¶å¯é æ€§å’Œå®‰å…¨æ€§ç›®æ ‡çš„å…³é”®

ä¸å¯å˜æ€§æœ‰åŠ©äºé˜²æ­¢æ•°æ®ç«äº‰å’Œå¹¶å‘é—®é¢˜

Shadowing Variables å¹¶ä¸æ˜¯é‡æ–°èµ‹å€¼

Rust å…è®¸ä½ éšè—ä¸€ä¸ªå˜é‡ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥å£°æ˜ä¸€ä¸ªä¸ç°æœ‰å˜é‡åŒåçš„æ–°å˜é‡ï¼Œä»è€Œæœ‰æ•ˆåœ°éšè—å‰ä¸€ä¸ªå˜é‡

- å¯ä»¥æ”¹å˜å€¼
- å¯ä»¥æ”¹å˜ç±»å‹
- å¯ä»¥æ”¹å˜å¯å˜æ€§







```rust
fn main() {
    // ä¸å¯å˜
    let a = 10; // è‡ªåŠ¨æ¨å¯¼ä¸º i32 ç±»å‹
    let b:i64 = 10; // æŒ‡å®šä¸º i64 ç±»å‹

    let c = "before";
    println!("before c: {}",c);
    // c = 20; // é”™è¯¯: Cannot assign twice to immutable variable [E0384]
    let mut c = "after";
    println!("after c: {}", c);
    // å¯ä»¥é‡å®šä¹‰ç±»å‹å¯å˜æ€§

    // å£°æ˜å¯å˜
    let mut d = 10;
    d = 20; // mut å¯ä»¥ä¿®æ”¹
    println!("use mut d: {}",d);
    // use mut d: 20
    // d = "string";// ä½†æ˜¯ mut åªèƒ½æ”¹ä¸ºç›¸åŒç±»å‹, é”™è¯¯: mismatched types [E0308] expected `i32`, found `&str`

    // åˆ‡å˜å¼•ç”¨  åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹ï¼Œé‡æ–°å£°æ˜äº†ä¸åŒç±»å‹çš„å€¼ï¼Œå®ƒè¦†ç›–äº†ä¹‹å‰çš„å€¼
    let e = 5;
    let e = 10;
    let e = "string";
    println!("final e: {}",e);
    // final e: string

    //shadowing
    let f = 10;
    { // æ–°çš„å‘½åç©ºé—´
        let f = 20; // å¯ä»¥èµ‹å€¼
        println!("inner x : {}",f)
    }
    // ç¦»å¼€ä½œç”¨åŸŸåï¼Œå†…éƒ¨çš„ e è¢«é”€æ¯äº†
    println!("outer x: {}",f);
    // inner x : 20
    // outer x: 10


    // æ²¡æœ‰ç”¨åˆ°çš„å˜é‡ä½¿ç”¨ _ ä½¿å…¶ä¸è­¦å‘Š
    let _g = 10;
}
```





# äºŒã€å¸¸é‡ä¸é™æ€å˜é‡

## const å¸¸é‡

- å¸¸é‡çš„å€¼å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æ—¶å·²çŸ¥çš„å¸¸é‡è¡¨è¾¾å¼ï¼Œå¿…é¡»æŒ‡å®šç±»å‹ä¸å€¼

- ä¸ C è¯­è¨€çš„å®å®šä¹‰ï¼ˆå®ä½“æ›¿æ¢ï¼‰ä¸åŒï¼Œ Rust çš„ const å¸¸é‡çš„å€¼ç›´æ¥è¢«åµŒå…¥åˆ°ç”Ÿæˆçš„åº•å±‚æœºå™¨ä»£ç ä¸­ï¼Œè€Œä¸æ˜¯è¿›è¡Œç®€å•çš„æ›¿æ¢

- å¸¸é‡åä¸é™æ€å˜é‡åçº¦å®šä¸ºå…¨éƒ¨å¤§å†™ï¼Œå•è¯ä¹‹é—´åŠ å…¥ä¸‹åˆ’çº¿ `USER_NAME`
- å¸¸é‡çš„ä½œç”¨åŸŸæ˜¯å—çº§ä½œç”¨åŸŸ `{}`ï¼Œå®ƒä»¬åªåœ¨å£°æ˜å®ƒä»¬çš„ä½œç”¨åŸŸå†…å¯è§







## static é™æ€å˜é‡

- ä¸ const å¸¸é‡ä¸åŒï¼Œstatic å˜é‡æ˜¯åœ¨è¿è¡Œæ—¶åˆ†é…å†…å­˜çš„
- å¹¶ä¸æ˜¯ä¸å¯å˜çš„ï¼Œå¯ä»¥ä½¿ç”¨ `unsafe` ä¿®æ”¹
- é™æ€å˜é‡çš„å£°æ˜å‘¨æœŸä¸ºæ•´ä¸ªç¨‹åºçš„è¿è¡Œæ—¶é—´





```rust
static MY_STATIC:i32 = 42;
static mut MY_MUT_STATIC:i32 = 42;

fn main() {
    // å¸¸é‡ const
    const SECOND_HOUR: usize = 3_600; // 3600 çš„æ›´æ˜“è¯»çš„å†™æ³•
    const SECOND_DAY: usize = 24 * SECOND_HOUR; //åœ¨ç¼–è¯‘çš„æ—¶å€™ä¼šè¢«ç¡®å®šï¼ˆç±»å‹å’Œå€¼ï¼‰
    println!("{}",SECOND_DAY);
    // 86400

    // å—çº§ä½œç”¨åŸŸ
    {
        const SE: usize = 1_000;
        println!("const scope: {SE}");// å¸¸é‡åªèƒ½åœ¨å—çº§ä½œç”¨åŸŸå†…æ‰“å°
        // scope: 1000
    }
    // println!("const {SE}");// ä¸å¯ä»¥åœ¨åœ¨å—çº§ä½œç”¨åŸŸå¤–æ‰“å°å—çº§ä½œç”¨åŸŸå†…çš„å¸¸é‡
    // error

    println!("static: {MY_STATIC}");
    // static: 42
    // No mut
    // MY_STATIC = 10; // é”™è¯¯: Cannot assign twice to immutable variable [E0384]
    // Use mut
    // MY_MUT_STATIC = 10; // é”™è¯¯: Use of mutable static is unsafe and requires unsafe function or block [E0133]
    // å¿…é¡»ä½¿ç”¨ unsafe è®¿é—® static mut å˜é‡
    unsafe {
        // å¯ä»¥ä¿®æ”¹
        MY_MUT_STATIC = 10;
        println!("inner: {MY_MUT_STATIC}")
        // inner: 10
    }
    //note: mutable statics can be mutated by multiple threads:
    // aliasing violations or data races will cause undefined behavior
    // println!("outer: {MY_MUT_STATIC}") // é”™è¯¯: ä¸å¯ä»¥è®¿é—®
}
```





# ä¸‰ã€åŸºç¡€æ•°æ®ç±»å‹

- Integer types é»˜è®¤æ¨æ–­ä¸º `i32`
    - `i8`  `i16`  `i32`  `i64`  `i128`
- Unsigned Integer Types
    - `u8`  `u64`  `u32`  `u64`  `u128` 
- Paltform-Specific Integer Type ï¼ˆç”±å¹³å°å†³å®šï¼‰
    - usize
    - isize
- Float Types
    - `f32` ä¸ `f64`
    - å°½é‡ä½¿ç”¨ `f64` ï¼Œé™¤éä½ æ¸…æ¥šè¾¹ç•Œéœ€è¦çš„ç©ºé—´ï¼Œå¹¶ä¸”å¸Œæœ›èŠ‚çœç©ºé—´
- Boolean Value
    - true
    - false
- Character Types
    - Rust æ”¯æŒ Unicode å­—ç¬¦ :laughing:
    - è¡¨ç¤º char ç±»å‹ä½¿ç”¨å•å¼•å·



```rust
use std::{isize, usize};

fn main() {
    // è¿›åˆ¶çš„å­—é¢é‡
    let a = -125; // åè¿›åˆ¶
    let b = 0xFF; // åå…­è¿›åˆ¶
    let c = 0o13; // å…«è¿›åˆ¶
    let d = 0b10; // äºŒè¿›åˆ¶
    println!("Decimal {a},\n Hexadecimal: {b},\n Octal: {c},\n Binary: {d}");
    println!("u32 max: {}",u32::MAX);
    println!("u32 max: {}",u32::MIN);
    println!("u32 max: {}",i32::MAX);
    println!("u32 max: {}",i32::MIN);
    println!("usize max: {}",usize::MAX);
    println!("usize is {} bytes",std::mem::size_of::<usize>());
    println!("isize is {} bytes",std::mem::size_of::<isize>());
    println!("u64 is {} bytes",std::mem::size_of::<u64>());
    println!("i64 is {} bytes",std::mem::size_of::<i64>());
    println!("u32 is {} bytes",std::mem::size_of::<u32>());
    println!("i32 is {} bytes",std::mem::size_of::<i32>());

    // float
    let e:f32 = 1.2345;
    let f:f64 = 6.7809;
    println!("Float are {:.2}, {:.2}",e,f); // {:.2} // åœ¨ç¬¬äºŒä½å››èˆäº”å…¥

    // bool
    let is_ok = true;
    let can_ok:bool = false;
    println!("is ok? {is_ok}\n can ok? {can_ok}");
    println!("is ok or can ok? {}\n can ok and is ok {}",is_ok || can_ok, is_ok && can_ok );

    // char
    let char_c = 'C';
    let emo_char ='ğŸ˜Š';
    println!("You get {}, and  feel {}",char_c,emo_char);
    println!("emoji's unicode number is {}",emo_char as usize);
}
// 
Decimal -125,
 Hexadecimal: 255,
 Octal: 11,
 Binary: 2
u32 max: 4294967295
u32 max: 0
u32 max: 2147483647
u32 max: -2147483648
usize max: 18446744073709551615
usize is 8 bytes
isize is 8 bytes
u64 is 8 bytes
i64 is 8 bytes
u32 is 4 bytes
i32 is 4 bytes
Float are 1.23, 6.78
is ok? true
 can ok? false
is ok or can ok? true
 can ok and is ok false
You get C, and  feel ğŸ˜Š
emoji's unicode number is 128522

```









# å…ƒç»„ä¸æ•°ç»„

- ç›¸åŒç‚¹

    - å…ƒç»„å’Œæ•°ç»„éƒ½æ˜¯ compound typesï¼Œè€Œ vec å’Œmap éƒ½æ˜¯ collection types

    - å…ƒç»„å’Œæ•°ç»„çš„é•¿åº¦éƒ½æ˜¯å›ºå®šçš„

- ä¸åŒç‚¹

    - Tuples ä¿å­˜ä¸åŒçš„æ•°æ®ç±»å‹

    - Arrays ä¿å­˜ç›¸åŒçš„æ•°æ®ç±»å‹



## æ•°ç»„

- æ•°ç»„æ˜¯é•¿åº¦å›ºå®šçš„åŒæ„é›†åˆ
- åˆ›å»ºæ–¹å¼
    - `[a, b, c]`æ”¾å…¥æ¯ä¸ªå…ƒç´ 
    - `[value; size]` å…ƒç´ åˆå§‹å€¼ï¼›æ•°é‡
- è·å–å…ƒç´  `arr [index]`
- è·å–é•¿åº¦ `arr. len()`

## å…ƒç»„

- å…ƒç»„æ˜¯å›ºå®šé•¿åº¦çš„å¼‚æ„é›†åˆ
- Empty Tuple ()
    - ä¸ºå‡½æ•°é»˜è®¤è¿”å›å€¼
- å…ƒç»„è·å–å…ƒç´ 
    - `tup.index`
    - æ²¡æœ‰ `len()`

```rust
use std::{isize, usize};

fn main() {
    let tup =(0,"str",2.3);
    println!("tup elements is {}, {}, {}",tup.0,tup.1,tup.2);
    // tup elements is 0, str, 2.3

    let mut tup2 = (0,"str", 2.3);
    println!("tup2 elements is {}, {}, {}",tup2.0,tup2.1,tup2.2);
    // tup2 elements is 0, str, 2.3
    // tup2.0 = 'f'; // é”™è¯¯: mismatched types [E0308] expected `i32`, found `char`
    tup2.1 = "string";
    println!("tup2 elements is {}, {}, {}",tup2.0,tup2.1,tup2.2);
    // tup2 elements is 0, string, 2.3

    let tup3 = ();
    println!("tup3 is empty: {:?}",tup3); // {:?} ä½¿å…¶å¯ä»¥è¢«æ‰“å°
    // tup3 is empty: ()

    // Array
    let mut arr = [11,12,34];
    arr[0] = 99;
    println!("arr let {} first element is {}",arr.len(),arr[0]);
    // arr let 3 first element is 99

    for element in arr {
        println!("{}",element);
    }

    let ar = [2; 3]; // [2,2,2]
    for i in ar{
        println!("{}",i)
    }
}
```













# æ‰€æœ‰æƒæœºåˆ¶

Ownership

ç±»å‹åŸºç¡€ç±»å‹ä¸æ•°ç»„ã€å…ƒç»„

å®ƒä»¬å’Œ string æ•°æ®ç±»å‹çš„ä¸åŒ

```rust
fn main() {
    // ownership
    let arr_item = [1,2,3];
    let tup_item = (2,"ff");
    println!("arr {:?}",arr_item);
    println!("tup {:?}",tup_item);

    let arr_ownership = arr_item;
    let tup_ownership = tup_item;
    println!("arr {:?}",arr_ownership);
    println!("tup {:?}",tup_ownership);

    let a = 3;
    let b = a;
    println!("{a}");
    // å˜é‡èµ‹å€¼é»˜è®¤æ‰§è¡Œçš„æ˜¯ copy æ“ä½œï¼Œ å˜é‡ a åœ¨èµ‹å€¼ç»“æŸåè¿˜æ˜¯å­˜åœ¨çš„
    println!("{b}");
    
    // move èµ‹å€¼ï¼Œä¼šæ›´æ”¹æ‰€æœ‰æƒ ownership
    let string_item = String::from("the string");
    let string_item_to = string_item; // String ç±»å‹å°±æŠŠ Ownership è¿›è¡Œäº† Move æ“ä½œï¼Œ string_item å°±ä¸å­˜åœ¨äº†
    println!("string_item is {}",string_item); // é”™è¯¯: value borrowed here after move 
}
```















