

# 所有权机制、结构体与枚举

## Ownership

类型基础类型、数组、元组和 string 数据类型的不同，string是一种复杂类型，它的变量赋值会导致所有权的转移

```rust
fn main() {
    // ownership
    let arr_item = [1,2,3];
    let tup_item = (2,"ff");
    println!("arr {:?}",arr_item);
    println!("tup {:?}",tup_item);

    let arr_ownership = arr_item;
    let tup_ownership = tup_item;
    println!("arr {:?}",arr_ownership);
    println!("tup {:?}",tup_ownership);

    let a = 3;
    let b = a;
    println!("{a}");
    // 变量赋值默认执行的是 copy 操作， 变量 a 在赋值结束后还是存在的
    println!("{b}");
    
    // move 赋值，会更改所有权 ownership
    let string_item = String::from("the string");
    let string_item_to = string_item; // String 类型就把 Ownership 进行了 Move 操作， string_item 就不存在了
    println!("string_item is {}",string_item); // 错误: value borrowed here after move 
}
```



# Rust 的内存管理模型

> stop the world
>
> 这是与垃圾回收（Garbage Collection）相关的术语，它指的是在进行垃圾回收的时候，系统暂停程序的运行
>
> 这个术语主要用于描述一种全局的暂停，即：所有应用程序线程都被停止，以便六级回收器能够安全地进行工作，这种全局性的停止会导致一些潜在的问题，特别是对于需要低延迟和高性能的应用程序
>
> 需要注意的是，并非所有的六级回收算法都需要“Stop the world”，有一些现代的垃圾回收器采用了一些技术来减少全局停顿的影响，比如并发垃圾回收和增量垃圾回收



> C/C++ 内存错误大全
>
> 1. 内存泄漏（Memory Leaks）
>     ```c
>     int* ptr = new int;
>     // 忘记释放内存
>     // delete ptr
>     ```
>
> 2. 悬空指针（Danagling Pointers）
>     ```c
>     int* ptr = new int;
>     delete ptr;
>     // ptr 现在是悬空的指针
>     ```
>
> 3. 重复释放 （Double Free）
>     ```c
>     int* ptr = new int;
>     delete ptr;
>     delete ptr;
>     ```
>
> 4. 数组越界（Array out of bounds）
>     ```c
>     int arr[5];
>     arr[5] = 10;
>     ```
>
> 5. 野指针
>
>     ```c
>     int* ptr;
>     *ptr = 10; // 野指针
>     ```
>
> 6. 使用已经释放的内存（Use After Free）
>      ```c
>      int* ptr = new int;
>      delete ptr;
>      *ptr = 10; // 使用已经释放的内存
>      ```
> 7. 堆栈溢出（Stack overflow）
>	
>     递归堆栈
>
> 8. 不匹配的 new / delete 或 malloc / free



- 所有权系统（Ownership system）

- 借用（Borrowing）
    - 不可变引用（借用）
    - 可变引变（可变借用）
- 生命周期（Lifetimes）
- 引用计数（Reference Counting）

```rust
fn get_length(str:String){
    println!("string is {}",str);
    // string is string
    // 函数结束之后销毁传入的参数
}

fn get_length_no_ownership(str:String) -> usize{ // usize 是返回类型
    println!("string is {}",str);
    // string is string
    str.len() // 返回
    // 函数结束之后，不销毁参数
}
fn main() {
    // copy  and move
    // copy
    let c1 = 1;
    // 如果是基础类型，会执行 copy 操作
    let _c2 = c1; // c1 仍然存在，
    println!("c1: {}",c1);
    // c1: 1

    let str1 = String::from("string");
    let str2 = str1; // str1 的所有权会转移给 str2， 所以 str1 就不存在了
    println!("str2 is {}",str2);
    // str2 is string
    // println!("str1 is {}",str1); //错误: value borrowed here after move
    let str3 = str2.clone(); // 执行 clone，所有权没有转移
    println!("str2 is {}",str2);
    // str2 is string
    println!("str3 is {}",str3);
    // str3 is string

    get_length(str2); // str2 的所有权被转移到了函数里面, 函数结束之后，str2 被销毁了
    // println!("str2 is {}",str2);// 错误: this parameter takes ownership of the value
    let str3_len = get_length_no_ownership(str3);
    println!("str3's length is {}",str3_len);
    // str3's length is 6

    let back = first_word("hello world");
    println!("one back is {}",back);
    let back  = first_word("we are the world");
    println!("two back is {}",back);


    // move
}

// 不能直接返回一个引用，所有权机制不明确
// fn dangle() -> &str{ // expected named lifetime parameter
//     // 因为无法确定生命周期
//     // 进而无法确定所有权什么时候销毁
// }

// 解决一
// 返回类型
fn dangle_owner() -> String {
    "string".to_owned()
}

// 解决二
// 静态的生命周期，在整个程序的运行期间都会存在
fn dangle_static() -> &'static str{
    "string"
}

// 传入一个切片引用，传出的也是一个切片引用
// String 与 &str vector u8 ref
fn first_word(s:&str) -> &str{
    let bytes = s.as_bytes();
    for(i,&item) in bytes.iter().enumerate(){
        if item == b' '{
            return &s[0..i];
        };
    }
    &s[..]
}
```



# String 与 &str

在 Rust 中表示字符串的两种类型， `String` 和 `&str`

- String 是一个堆分配的可变字符串类型

    源码:

    ```rust
    pub struct String {
    	vec: Vec<u8>
    }
    ```

- `&str` 是指字符串切片引用，是在栈上分配的
    - 不可变引用，指向存储在其他地方的 UTF-8 编码的字符串数据
    - 由指针和长度构成

> [!NOTE]
>
> 注意 String 是具有私有权的，而 &str 没有

- `Struct` 中属性使用 `String`
    - 如果不使用显式声明生命周期，无法使用 `&str`
    - 不只是麻烦，还有更多的隐患
- 函数参数推荐使用 `&str`（如果不想交出所有权）
    - &str 为参数，可以传递 `&str` 和 `&String`
    - `&String` 为参数，只能传递 `&String` 不能传递 `&str`


字面量 to String

```rust
fn main(){
    // String to &str 的三种方法
    // String::from() 一
    // .to_string() 二
    // .to_owned() 三
    let name = String::from("Value C++");
    let course = "Rust".to_owned(); // 方法一： 从字面量转 String
    let new_name = name.replace("C++","CPP");
    println!("name: {name} \ncourse: {course} \nnew_name: {new_name}");
    // Value C++
    // Rust
    // Value CPP

    let rust = "\x52\x75\x73\x74"; // ASCII
    println!("ASCII is {rust}")
    // ASCII is Rust
}
```

字符串的字面量实际上就是一个切片引用

Struct

```rust
// 结构体
struct Person_v1 {
    // gender:&str,// 生命周期未指定错误：Missing lifetime specifier [E0106]
    name:String,
    color:String,
    age: i32
}

struct Person<'a> {
    name:&'a str, // 表示字面量的生命周期和结构体的生命周期是一样的  // 传入字面量
    color:String,// 传入字符串类型
    age: i32
}

fn main(){
		// Struct
    let color = "green".to_string();
    let people = Person{
        name: "john", // 字面量
        color:color, // 字符串
        age:89,
    };
}
```

Function

```rust
// 可以传入 &String 字符串 和 &str 字面量
fn print(data:&str){
    println!("data: {data}")
}

// 只能传入 &String 字符串
fn print_string_borrow(data:&String){
    println!("borrow data: {}",data);
}
fn main(){
    let value = "value".to_string();
    // print(value); // 类型错误：mismatched types [E0308] expected `&str`, found `String`
    print(&value); // 传入 String 的引用
    // data: value
    print("the date"); // 传入字面量
    // data: the date

    // print_string_borrow("the data borrow");// 类型错误：mismatched types [E0308] expected `&String`, found `&str`
    print_string_borrow(&value); // 传入 String 的引用
    // borrow data: value
}
```





# 枚举与匹配模式

- 枚举（enums）是一种用户自定义的数据类型，用于表示具有一组离散可能值的变量
    - 每种可能值都被称为 “variant”（变体）
    - `枚举名::变体名`
- 枚举的好处
    - 可以使你的代码更严谨、更易读
    - More robust programs

```rust
enum Shape{
	Circle(f64),
  Rectangle(f64,f64),
  Square(f64),
}
```

## 常用的枚举类型

-  Option  返回值的内容或者没有值

```rust
pub enum Option<T> {
	None,
  Some<T>
}
```

- Result  返回成功或失败原因

```rust
pub enum Result<T,E>{
	OK(T),
  Err(E)
}
```





## 匹配模式

1. `match` 关键字实现
2. 必须覆盖所有的变体
3. 可以使用 `_` 、 `..=`  、三元`if` 等来进行匹配

```rust
match number {
	0 => println!(""Zero), // 仅匹配 0
  1 | 2 => println!("One or Tow"), // 匹配 1 或 2
  3..=9 => println!("From Three to Nine"), // 范围 3～9 匹配
  n if n % 2 == 0 => println!("Even number"), // 三元匹配 如果为 true 执行 print 操作
  _ => println!("Other"), // 匹配剩余的所有
}
```



```rust
enum Color{
    Red,
    Yellow,
    Blue,
    Black
}

fn print_color(my_color:Color){
    match my_color {
        Color::Red => println!("Red"),
        Color::Yellow => println!("Yellow"),
        Color::Blue => println!("Blue"),
        _ => println!()
    }
}

fn main(){
    print_color(Color::Red);
    // Red

    print_color(Color::Black);
    // 未匹配到， 什么都不做

    let a = Color::Red;
    print_color(a);
    // let b = a; // 错误：Use of moved value // a 的所有权已经被转移给之前传入的函数了
}
```

在枚举中使用关联函数

```rust
enum BuildingLocation{
    Number(i32),
    Name(String), // 不要用 &str
    Unknown, // 没有任何信息
}

// 关联函数
impl BuildingLocation {
    fn print_location(&self){ // 如果不使用 &self 则在调用的时候为 BuildingLocation::print_location()
        match self {
            BuildingLocation::Number(c) => println!("building number {}",c), // 使用 BuildingLocation(3) 此时的 c 就是 3
            BuildingLocation::Name(s) => println!("building name {}",*s),//使用 buildingLocation("ok".to_string())
            BuildingLocation::Unknown => println!("Unknown")
        }
    }
}
fn main(){
    let house = BuildingLocation::Name("bud".to_string());
    house.print_location();
    // building name bud
    let house2 = BuildingLocation::Number(12);
    house2.print_location();
    // building number 12

    let house3 = BuildingLocation::Unknown;
    house3.print_location();
    // Unknown
}
```



# 结构体、方法、关联函数、关联变量

## 结构体

结构体是一种用户定义的数据类型，用于创建自定义的数据结构。

```rust
struct Point{
	x:i32,
  y:i32,
}
```

每条数据（x 和 y）称为属性（字段 field），通过`.` 来访问结构体中的属性



### 结构体中的方法

结构体中的方法是指，通过实例调用（self、&mut self、self）

```rust
impl Point{
	fn distace(&self,other:&Point) -> {
  	let dx = (self.x - other.x) as f64;
  	let dy = (self.y - other.y) as f64;
  	(dx * dx + dy * dy).sqrt()
  }
}
```

### 结构体中的关联函数

关联函数是与类型相关联的函数，调用时为  `结构体名::函数名`

```rust
impl Point {
	fn new (x: u32, y: u32) -> Self{ // Self 大写，指的是 Piont
		Point {x,y}
	}
}
```

### 结构体中的关联变量

这里的关联变量是指，和结构体类型相关的变量，也可以在特质或是枚举中

```rust
impl Point {
	const PI:f64 = 3.14;
}
```

调用时使用 `Point::PI`



```rust
enum Flavor {
    Spicy,
    Sweet,
    Fruity,
}

struct Drink{
    flavor:Flavor,
    price:f64,
}

fn print_drink(drink:Drink) {
    match drink.flavor {
        Flavor::Fruity => println!("fruity"),
        Flavor::Spicy => println!("spocy"),
        Flavor::Sweet => println!("sweet"),
    }
    println!("{}", drink.price);
}

impl Drink{
    // 关联变量
    const MAX_PRICE: f64 = 10.0;

    // 方法
    fn buy(&self){
        // if self.price > Self::MAX_PRICE{
        if self.price > Drink::MAX_PRICE{
            println!("I am poor");
            // return
        }else {
            println!("buy it");
        }
    }
    // 关联函数
    fn new(price:f64) -> Self{
        Drink{
            flavor:Flavor::Fruity,
            price,

        }
    }
}

fn main() {
    let sweet  = Drink{
        flavor: Flavor::Sweet,
        price:6.0,
    };
    println!("{}",sweet.price);
    print_drink(sweet); // 所有权丧失了， sweet 被销毁了

    let sweet2 = Drink{
        flavor: Flavor::Sweet,
        price: 10.0,
    };
    sweet2.buy();

    let sweet3 = Drink::new(12.0);
    sweet3.buy()
}
```

